% Perl によるプログラミング入門 in 東海
% 第二回 - プログラムの構造化
% 2016/03/27 第一版

---

# はじめに

## お久しぶり

お久しぶりです．前回のテキストを読んでもらったのかもしれません．
読んでもらっていないかもしれません．
このテキストは，前回のテキストを読んだ前提で書いています．
題材が同じなので，もし前回のテキストをまだ読んでいなければ，参照しなが
ら見るとやりやすいと思います．

前回は，プログラムを勉強し始めた人向けの内容を目指しました．
今回は，プログラムは一通り書けるけど，その次の段階の人向けです．
やっつけ仕事より，もう少し長く使うプログラムを書くことを想定しています．
まったくの初心者ではないけど，まだなんとなく書いている人，プログラミングの基礎を一緒に学びましょう．

プログラミングの世界へようこそ．サポータはあなたを手助けをします．
このテキストは，一人でも読めるように考えて書きますが，
必要であれば，誰かに助けを求めてください．ここに居るならサポータが．
一人で読んでいるなら，インターネットの誰かが助けてくれるでしょう．

---

# おさらい

## TODO リスト

前回は TODO リストを作りました．
作ったTODO リストいくつか機能がありました．一覧にします．

* TODO リストを保存するファイルを初期化できる
* TODO リストを追加する
* TODO リストの TODO を全部表示する
* TODO リストの TODO を完了にする
* TODO リストのうち未完了な TODO だけを表示する

## できるようになったこと

プログラミングのやり方をいくつか学びました．

* 準備
    * プログラムファイルをテキストファイルで編集する
    * プログラムファイルをコンソールで実行する
* Perl
    * 意図
        * `#` から行末までは，コメントとなり，読む人に意味を伝える
        * 空行は，意味のかたまりを分割するために入れる
    * 単一の値，スカラ
        * 文字列，数値，`undef`，ファイルハンドル がある
        * 真偽値(ブーリアン) としても使われる
            * 偽: `""`, `"0"`, `0`, `undef`
            * 真: それ以外
        * スカラ変数は，`$` が先頭
    * 複数のスカラ値を持つ，リスト
        * スカラを複数をひとまとめにする
        * リスト変数は，`@` が先頭
        * `[]` と添字(数字)で個別のスカラ値を参照できる．
        * スカラ変数のように扱うには，`$` + 変数名 + `[` + 添字 + `]`
        * 添字は，`0` から始まる
    * 変数
        * 値に別名をつける機能
        * 代入 `=`(イコール) によって，変数と値をひもづける
        * 最初に使うときに `my` をつける
    * 演算子
        * 1つ以上のスカラ値をスカラ値，又はリスト値に変換する
        * スカラでも特にブーリアンを入力，出力に持つ演算子もある
        * 引数の位置で呼び出し方は色々
            * ブーリアン → ブーリアン: `not` + 引数
            * 数値，数値 → 数値: 引数1 + `+` + 引数2
            * ファイルハンドル → 文字列 or 文字列のリスト: `<` + 引数 + `>`
    * 関数
        * 0個以上の引数与えて，何か処理をさせる．返り値がある．
        * 関数名 + `(` + 引数1 + `,` + 引数2 + ... + `)`
        * `print()`
            * 引数をファイルハンドルに出力する．ファイルハンドルを指定
              しなければコンソールに出力する
        * `open()` / `close()
            * ファイルにひもづけられたファイルハンドルを作ったり，破棄したりする
        * `chomp()`
            * 文字列の最後の改行文字を削除する
            * 値を返すというよりは，指定された変数の文字列そのものを変更する
        * `push()`
            * 指定されたリスト変数の末尾に要素を追加する
        * `split()`
            * 文字列を分解したリストを返す
    * 制御構造
        * `if` で，処理するかしないかを制御できる
            * `if (A) {B}` の形式で使う．A はブーリアン．B は0 個以上の式．
        * `while` で処理を繰り返すことができる
            * `while (A) {B}` の形式で使う．A はブーリアン．B は0個以上の式．
            * A の結果が変わらないと繰り返しが終わらないので注意
        * `foreach` でも処理を繰り返すことができる
            * `foreach` + 繰り返し変数 + `(` + 繰り返すリスト値 + `) + {B}` の形式で使う
            * リストが最初にあるので，繰り返す回数はリスト値の個数
    * コンテキスト
        * 何が求められているかで，演算子や関数の戻り値が変わる．その求められ方
        * スカラコンテキスト
            * スカラ値を期待されているコンテキスト
            * 例: スカラ変数への代入(`=`)，演算子の引数，`if` などの条件部分，
        * リストコンテキスト
            * リスト値を期待されているコンテキスト
            * 例: リスト変数への代入(`=`)，関数の引数．

---

# 確認するプログラムを書く

前回のテキストをやった人は，結果を目で確認してきたと思います．
プログラムを便利に使う次の一歩として，自分の書いたプログラムの動作を
自分の書いたプログラムで確認できるようにしましょう．

前回のテキストをやっていない人は，01\_hello.pl をコピーして，
実行できるようにしておいてください．

現在のディレクトリに 01\_hello.pl が存在していて，実行可能なことを
確認してから次のステップに進んでください．

## シンプルな例

### 01_hello.t

```{.perl .numberLines}
#!/usr/bin/env perl

use strict;
use warnings;

use Test::More; # is() / done_testing() 関数を使うために必要

# プログラム名の指定
my $program = "./01_hello.pl";

# プログラムの実行，実行結果の取得
my $got = `$program`;

# 実行結果(got)，と 期待する結果(expected) の比較
my $expected = "Hello, World\n";
my $message = "test for stdout";
is($got, $expected, $message);

# テスト実行完了を宣言
done_testing();
```

## 概略説明

`.t` 拡張子(ファイル名の最後の `.` (ドット) 以降の文字列) は，
テスト(test)の頭文字です．
動作確認のことをテストと呼ぶことが多いようです．
拡張子は，`.pl` ではないですが，これも Perl 言語のプログラムファイルです．

`#` の行，`use strict; use warnings;` の行は説明の必要はないでしょう．
必要がある人は，前回のテキストを読んでみてください．

`use Test::More;` は，テストに使う関数を使えるようにしています．
このプログラムでは，`is()` と `done_testing()` という関数を使っています．

`is($got, $expected, $message);` は,
`$got` の中身が `$expected` と等しかったら確認 `ok` としています．
`$message` は，結果を出力するときに，複数テストしたときに
どのテストが `ok` かをわかりやすくするためのメッセージです．

`done_testing()` は，テストの終わりを意味します．

## 実行

細かい説明の前に，実行してみましょう．
このファイルは Perl 言語のプログラムファイルですので，
`perl プログラムファイル` のように実行します．
これも前回にやりました．

結果は，

```{.numberLines}
ok 1 - test for stdout
1..1
```

のようになったと思います．

`ok` は，確認できた．という意味です．`is()` 関数の出力と思うとよいでしょう．
全部が `ok` なので，すべてが問題ない状態です．

例えば，このように書き換えて実行してみましょう．

01\_hello\_ng.t

```{.perl .numberLines}
#!/usr/bin/env perl

use strict;
use warnings;

use Test::More; # is() / done_testing() 関数を使うために必要

# プログラム名の指定
my $program = "./01_hello.pl";

# プログラムの実行，実行結果の取得
my $got = `$program`;

# 実行結果(got)，と 期待する結果(expected) の比較
my $expected = "aaa" . "Hello, World\n";
is($got, $expected, "test for stdout");

# テスト実行完了を宣言
done_testing();
```

結果は，`not ok` を表示して，何やらメッセージが出るようになりました．

```{.numberLines}
not ok 1 - test for stdout
#   Failed test 'test for stdout'
#   at 01_hello_ng.t line 16.
#          got: 'Hello, World
# '
#     expected: 'aaaHello, World
# '
1..1
# Looks like you failed 1 test of 1.
```

これは，実行したプログラムの結果として `Hello, World\n` が得られた(get)けど，
期待していた(expected) のは `aaaHello, World\n` だったよ．
ということを意味します．
結果と期待したものの両方を表示してくれています．

このように，プログラムでプログラムの結果を確認することができます．

これくらい簡単なプログラムなら `ok` / `not ok` を表示させること，と，
自分の目で確認するのとでは，むしろ面倒になっています．
結果が複雑だったり，確認する項目や回数が増えてくると，
テストプログラムで確認した方が楽になります．

## 解説

では，使っている機能の説明をしましょう．

### モジュール / プラグマ

プログラムのパーツを封じ込めたものです．
`perl` に最初から同梱されているものと，
後でインストールするものがあります．
自分で作ることもできます．
`use` でその機能を使う宣言をします．

機能はそれぞれのモジュール毎に異なります．
モジュール名は大抵大文字から始まります(例: `Test::More`)．
`strict`, `warnings` は，プラグマ(pragma) といってモジュールとは異なりますが，
プログラムに機能を追加するという点では同じものです．

### Test::More モジュール

`Test::More` テストを書くための機能を提供するモジュールです．

今回主に使うものは以下の関数です．


`is()` 関数

:   A is B のように，2つのものが等しいことを確認するために使います．

    1番目の引数が，実行結果，

    2番目の引数が，期待した値です．

    3番目の引数が，メッセージです．テスト結果に表示できます．省略可能です．

`done_testing()` 関数

:   テストプログラムファイルの終わりに書きます．
    プログラムが確認したテストの個数を数えるのに使います．

### ``` `` ``` (バッククォート) 演算子

``` `` ``` バッククォート演算子は，`` ` + 文字列 + ` `` の形式で，
文字列部分を実行した結果を返します．

今回は，自分が書いたPerlプログラムを指定していますが，
システムに存在するプログラムを実行することもできます．

* 文字列 → 文字列 又は 文字列のリスト : `` ` + 文字列 + ` ``
    * 結果は実行した結果の標準出力

## 練習問題

1. システムに乗っているプログラムの実行結果を比較するテストプログラムを書いてください．
   (Windows なら `dir`，Mac，Linux の人は `ls` などは比較的使い易いでしょう)
2. いくつかの演算子の機能を試してみてください
   (`+`, `-`, `*`, `/`, `.`, `x`, `==`, `eq`, `not`, `and`, `or`, ...)
3. くりかえしの機能を試してみてください
   (`while`, `foreach` の中で `is` を使ってみてください．ブロックの中
   で計算した結果を確認するのもよいでしょう)

---

# TODO リストプログラムを確認するためのテストプログラムを書く

前回のテキストで作った以下のプログラムの動作を確認するテストプログラムを書きます．

* 03\_init\_todo.pl
* 04\_add\_todo.pl
* 05\_list\_todo.pl
* 06\_done\_todo.pl
* 07\_list\_notyet\_todo.pl

まず，例を示しましょう．

## TODO リスト初期化プログラムをテストする

### 03_init_todo.t

```{.perl .numberLines}
#!/usr/bin/env perl

use strict;
use warnings;

use Test::More; # is() / done_testing() 関数を使うために必要
use File::Temp ("tempdir"); # tempdir() 関数を使うために必要
use Cwd; # pwd() 関数を使うために必要

# 実行するファイル名を指定する
my $program_filename = "03_init_todo.pl";
my $pwd = cwd();
my $program_fullpath = join("/", $pwd, $program_filename);

# todolist.txt を出力するための一時ディレクトリを作成し，実行し，結果を比較する
# (この一時ディレクトリは自動的に削除される)
{
    # 一時ディレクトリの作成
    my $tmp_dirname = tempdir(CLEANUP => 1);

    # プログラムの実行
    chdir($tmp_dirname) or die; # 現在のディレクトリを一時ディレクトリにする
    `$program_fullpath`; # プログラムの実行

    # 実行結果の取り出し
    open(my $fh, "<", "$tmp_dirname/todolist.txt") or die;
    my $got = join("", <$fh>);
    close($fh) or die;

    # 実際の値(got)と期待する結果(expected) を比較
    my $expected = "sample todo\n"; # 期待する結果
    is($got, $expected);
}

done_testing(); # テストの終了を宣言
```

## 概要

急に長くなりましたね．
長いので，コメントを入れておきました．
前回にも書きましたが，空行で意味の区切りを作っています．

* いつもの
* 必要な関数の準備 → モジュール
* 実行するファイル名の準備
* 一時ディレクトリの準備
* プログラムの実行
* 実行結果の取り出し(データファイル)
* 実際の値，期待する値の比較

プログラムを実行して，結果を比較する部分は，シンプルな例と同じです．

ポイントは，ディレクトリを変更してからプログラムを実行している部分です．
意識していなかったかもしれないですが，
前回書いたプログラム(`03_init_todo.pl`)は，データファイル(`todolist.txt`) を，
実行したディレクトリに置きます．

実行するディレクトリを変えないとどうなるでしょうか？

前回テストを実行したときのデータファイルが残っていたり，
最悪，自分の使っているデータファイルが消えてしまいます．
これは嬉しくないでしょう．

そこで，このテストプログラムでは，テスト対象のプログラムを実行する前に，
現在のディレクトリから移動しています．
移動する先は，一時的に作ったもので，最初は空の状態です．

## 説明

### File::Temp モジュール

tmpdir() 関数

:   一時ディレクトリを作成する

### Cwd モジュール

chdir() 関数

:   現在のディレクトリを変更する

### ブロック

---

# 機能追加

---

# まとめ

---

# おさらい

この会で Perl プログラミングについて学んだことをおさらいします．

---

# 練習問題の答

---

# 付録

---

# さいごに

これを読んだ人がプログラミングを挫折しないで学べるようになることを望んで書きました．

なるべく覚えることを減らして，1つの章でポイントを絞って書くようにしました．
その代わり網羅性は考えないことにしました．一般のプログラミング言語の入門書に通常あるようなことでも書いていないことがあります．
10個のことを覚えるより，1つのことを10回やった方がうまくなると思っているからです．

勉強した方の生活がどこか楽になってくれると嬉しく思います．

---
