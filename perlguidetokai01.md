% Perl によるプログラミング入門 in 東海
% 第一回 - プログラムの基礎文法
% 2016/02/20 第一版

---

# はじめまして

## はじめに

ここに来たということは，プログラミングを勉強しようと思って来たと思っています．
プログラムで何かやろうと思っていることがあるかもしれませんし，
まだそこまでイメージできていないけど，とりあえず勉強しよう．
ということかもしれません．

プログラミングの世界へようこそ．サポータはあなたを手助けをします．
このテキストは，一人でも読めるように考えて書きますが，
必要であれば，誰かに助けを求めてください．ここに居るならサポータが．
一人で読んでいるなら，インターネットの誰かが助けてくれるでしょう．

---

# Perl について

## Perl 言語

幸か不幸か，ここではプログラミング言語に Perl を選択しています．
少しだけ Perl 言語についてお話しします．

Perl 言語は，3分間で書き上げるようなやっつけ仕事にも，本格的なプログラムにも適しています．
特に，テキスト処理が90%，その他が10% くらいの処理を書くのに適しています．
逆に，バイナリデータ[^binary_data]の処理は不得意です．

[^binary_data]: バイナリデータとは，テキストではないデータです．つまり人が読めない形式のデータです．

Perl は無料で手に入ります．

---

# 最初のプログラム

まずは，プログラムを書いてみて雰囲気を掴みましょう．

## プログラムを書いて，実行してみましょう

- 作業用ディレクトリ(フォルダ)を作りましょう
    - ディレクトリ名: `perl20160220`
- テキストエディタを開きます
    - テキストエディタで作業フォルダ内にファイルを作りましょう
    - ファイル名: `01_hello.pl`
- コンソール(コマンドプロンプト)を出して作業フォルダに移動しましょう
    - 作業フォルダ内のファイルを実行しましょう
    - 例: `perl 01_hello.pl`
- 結果，コンソールに `Hello, World` と表示されたことを確認しましょう

### 実行例

```{.bash .numberLines}
$ mkdir perl20160220
$ cd perl20160220
$ edit 01_hello.pl
$ perl 01_hello.pl
```

### 01_hello.pl

```{.perl .numberLines}
#!/usr/bin/env perl

use strict;
use warnings;

print("Hello, World\n");
```

## 解説 - 周辺

まず，プログラムを実行するには，どのプログラムファイルを実行するかを指定しなければなりません．
どこにプログラムファイルを置いたかすぐわかるように，今日一日は，同じ作業ディレクトリで作業するようにしましょう．

`perl 01_hello.pl` という呪文でプログラムを実行しました．
これは，`perl` というコマンド(命令) を使って，`01_hello.pl` というファイルをPerl 言語で書かれたプログラムファイルとして実行した．ということです．
`perl + プログラムのファイル名` という形式は今後も使いますので，慣れておいてください．

では，プログラムファイルの解説に移りましょう．

## 解説 - プログラムファイル

Perl 言語は，上から順番に処理が進む，逐次処理を基本とします．
プログラムファイルは，テキストファイルです．ソースコードやソース，ソースファイルとも呼ばれます．

Perl 言語で書かれたソースコードの中では，`#` (シャープ) から行末まではコメント(説明文) の意味になります．
コメントは，プログラムとしては何も実行されず，意味がありません．
ですが，プログラムが何をしているかをソースコードを読む人に説明するために使います．

```{.perl .numberLines}
#!/usr/bin/env perl     # <= Perl で動作するようにシェルに伝える

use strict;   # 文法を厳密にチェックする
use warnings; # 警告を出す

print("Hello, World\n"); # 端末に文字列を出力する
```

最初の行は，Mac, Linux の人には意味があります．
先程，`perl + プログラムのファイル名` という形式で，Perl 言語のプログラムファイルを実行すると言いましたが，実は，Mac や Linux の人には必要ありません．
`./プログラムファイル名` のような形式で実行することができます．
プログラムファイルは，`perl` コマンドで実行すると，この行に書かれています．

Windows の人は，ファイル名の拡張子部分で判定するようになっているので，
この行には意味がありません．

それ以外の環境の人は，その環境に詳しい人に聞いてください．

次の行の，`use strict; use warnings;` の部分は，警告を多めに出すように指定してあります．
慣れないうち，慣れていても，情報が多い方が何かがあったときに気付きやすいので，
この 2行は基本的には書きましょう．

ここまでは，プログラムの動作にはあまり関係ありませんでした．
残りの1行が，このプログラムファイルの本体です．

この行は，`print()` という関数を使って，コンソールに出力しています．
プリントのくせに，プリンタへの出力ではありません．
出力した内容は，`"Hello, World"` であって，`"Hello, World\n"` ではありません．
`\n` はどこへ行ってしまったのか．
その部分を削除するなどして確かめてみてください．

意外に重要なのが，`;` (セミコロン) で，
1つの文の区切りを意味します．

空行(からぎょう) ，つまり行に空白文字やタブ文字以外何も書いていないものも，プログラムとして何もしません．
コメントと同様に，プログラムファイルを読む人に意味上の区切りを表現するために使うことが多いようです．
この会の中に出てくる例でも，そのように使います．
日本語の文章で言うところの，段落，のようなものでしょうか．

## 練習問題

1. 自分の力で，`01_hello.pl` を作って実行してみましょう
2. 他にも何かを表示してみましょう(名前，年齢など)
   (1つのプログラムファイルに，2つ以上の`print()`関数を使ってみてください．)
3. `perldoc -u -f atan2` を実行してみましょう
4. 以下のソースコードをファイルに保存して，実行して，結果を比較してみましょう．何が変わったでしょうか？

```{.perl .numberLines}
#!/usr/bin/env perl

use strict;
use warnings;

my @lines = `perldoc -u -f atan2`;
foreach (@lines) {
    s/\w<([^>]+)>/\U$1/g;
    print;
}
```

---

# まずはプログラミングに慣れる

プログラミングといってもあまり怖がる必要はありません．
簡単なところから初めましょう．

## 簡単な計算

プログラミング言語では，数値計算ができることが多いです．
Perl でも，四則演算など基本的な計算が可能です．

### 02_calc.pl

```{.perl .numberLines}
#!/usr/bin/env perl

use strict;
use warnings;

print(1 + 1, "\n");  # => 2

my $x = 10;
print($x * $x, "\n"); # => 10 * 10 => 100
```

## 解説 - 値 と 変数

最初の行は，`1 + 1` を計算した結果を，コンソールに出力しています．
`print()` は，コンソール出力をする命令でした．
`1 + 1` は，ご存知の通り，数値計算です．
`+` という*演算子*は*数値*と*数値*を足して，新しい*数値*を作ります．
この場合は，新しい数値は，`print()` 文によってコンソールに出力しています．

次の文 `my $x = 10` は，`$x` という*変数*に*数値* という値を代入しています．
代入というのは*値* に，名前を付けることです．
この場合，名前は `$x` です．
代入の前に `my` が付いています．これは今はあまり気にしないでください．
変数を最初に使う場所で使います．

`10` に `$x` という名前を付けました．
次に `print($x * $x, "\n")` という文で，`$x` 掛ける `$x` を計算しています．
`$x` は `10` でしたので，`10 * 10` の計算と同じ意味になります．

## 単語 - 値，変数

### 値，スカラ

新しい言葉がいくつか出てきたので，まとめておきます．

*値* とは，Perl で扱える最小単位のデータです．
*スカラ* とも言います．

*スカラ* には，*文字列*と*数値* があります．
スカラの種類はそれ以外にもありますが，一番使うこれらを覚えておけばよいでしょう．

*文字列* を作るには，以前出てきたように，ダブルクォートを使います．
*数値* を作るには，0 から 9 と . (ドット)などから作ることができます．

* スカラ．値
    * 文字列
        * 例: `"\n"`, `"Hello, World\n"`
    * 数値
        * 例: `1`, `2.5`

### 演算子

Perl では，数学の演算子をいくつか使うことができます．
`+`, `-`, `*`, `/` です．掛け算，割り算の記号はなじみがないかもしれませんが，
こういう記号を使います．

四則演算は，全て *数値* に対しての演算でした．
例えば，`+` (足し算) は，2つの*数値* を使って，1つの*数値* を得るための演算です．

*文字列* に作用する演算子もあります．
`.` (ドット) です．これは *文字列* と *文字列* を結合して，
新しい*文字列* を作ります．

```{.perl .numberLines}
print("abc" . "def", "\n"); # => abcdef が表示される
```

*文字列* と *数値* の両方使う演算子もあります．
`x` は，文字列の繰り返しの意味の演算です．
*文字列* と繰り返しの数の*数値* を使って，新しい*文字列* を返します．

```{.perl .numberLines}
print("a" x 3, "\n"); # => aaa が表示される
```

* 演算子．
    * 数値，数値 → 数値
        * 四則演算: `+`, `-`, `*`, `/`
    * 文字列，文字列 → 文字列
        * 文字列連結: `.` (ドット)
    * 文字列，数値 → 文字列
        * 文字列の繰り返し: `x`
  
### 関数呼び出し

`print()` について少し解説します．
`print()` は，コンソールに出力する命令でした．
このような命令は，*関数* と呼ばれます．

関数は，`関数名 + "(" + 引数1 + "," + 引数2… + ")"` の形式で呼び出されます．
今後もいくつか関数が出てきますが，基本は同じ呼び出し方です．
(例外もあります)

`print()` は，引数をすべて連結してコンソールに出力します．

* 関数呼び出し
    * 例: `print(1 + 1, "\n")`

### スカラ変数

*変数*は，値に名前を付けるための機能です．

変数を使うときには，最初だけ `my` を使います．
これを変数の *宣言* と呼びます．

特にスカラに関連させる変数をスカラ変数と呼びます．
スカラ変数は，`"$" + 変数名` の形式にします．

`my` には，変数の有効期間を設定する機能もありますが，
今はあまり意識しなくともよいでしょう．

* 変数
    * 最初だけ `my` で宣言する
    * スカラ変数
        * `$ + 変数名` の形式で使う
        * `変数 = 値` で，変数に値をひもづけます．
            * 例: `$num = 10`, `$greeting = "おはよう"`
        * `変数` の形式で変数にひもづいた値を使えます
            * 例: `$x = 10; $x + 1; # => 11`

## 練習問題

1. いくつか計算してみましょう．例 `1 + 2 * 3`．答えは思い通りになりましたか？
2. 半径12.5の円の円周の長さを求めるプログラムを書いてください．
   円周の長さは半径の 2π 倍 です．答えは，78.5 くらいになる筈です．
   (半径は，`$r` というスカラ変数に入れてみてください．πの値は 3.14 として計算すると良いでしょう．)

---

# 今回目指すもの

この会では，TODO リストを作りながら，一緒にプログラミングについて学びます．
TODO リストとはどんなものでしょうか？
今回目指すTODOリストの機能を考えてみましょう．

## 今回目指すもの

TODO リストを扱うプログラムを作ります．TODO リストにはどんな機能があるでしょうか？
今回，私達の作る TODOリストは，以下のような機能を持っています．

* TODO を保存，操作します
* TODO の状態は，未実施，完了 があります．
* TODO には内容(content)があります．
* TODO の状態を，完了にできます．

## 練習問題

* 自分でも TODO リストに欲しい機能を考えてみましょう

---

# TODO リストを保存する

ではまず，固定の TODO リストを作成するプログラムを作ってみましょう．

## 03_init_todo.pl

```{.perl .numberLines}
#!/usr/bin/env perl

use strict;
use warnings;

# 新しいファイルに書き込む
open(my $fh, ">", "todolist.txt") or die;
print($fh "sample todo\n");
close($fh) or die;
```

## 解説

これは，`open(...` 以降がプログラムの本体です．
このプログラムは，`"todolist.txt"` というファイルを新しく作って，
`"sample todo"` という内容のTODO を保存しています．

新しい関数が出てきたので，順に説明します．
説明後にまたこのプログラムを見たら理解できるでしょうか？

## open() / close() 関数

ファイルの中身を読み込んだり，書き込んだりするための準備や後片付けが必要です．
それを行うのが，`open()`，`close()` 関数です．

`open()` 関数は，*引数* が3つあります．

* 1つめは，ファイルハンドルを保存する先の変数です．`my $fh` の部分です．
  ファイルハンドルというのは，ファイルを扱うためのスカラ値です．
  引数で指定した変数に，ファイルハンドルというスカラ値が代入されます．
  `=`(イコール) ではありませんが代入されます．
  ファイルハンドルは，数値でも文字列でもありません．
  説明したことがないスカラ値です．
  `print()` 関数のところでもう少し説明します．
* 2つめは，モードです．書き込みか読み込みかを文字列で指定します．
    * `"<"` は読み込み
    * `">"` は書き込みで，新規ファイルを作って先頭から書き込みます
    * `">>"` は，追記書き込みで，ファイルの末尾に追記します
* 3つめは，ファイル名です
    * ファイル名だけ書くと，プログラムを実行したディレクトリと同じ場所
      のファイルと考えます．

`close()` 関数は，ファイルハンドルの後片付けをします．
`open()` したら `close()` を忘れないようにしましょう．

ファイルの書き込み読み込みは，以下のような形が基本です．
覚えましょう．

書き込み

```{.perl .numberLines}
open(my $fh, ">", "filename") or die;
# 何か処理をする - print($fh "XXX\n")
close($fh) or die;
```

読み込み

```{.perl .numberLines}
open(my $fh, "<", "filename") or die;
# 何か処理をする - まだ説明していない入力
close($fh) or die;
```

`or die` については，ちょっと難しいので，
とりあえずこういうものだとして覚えてください．
この記述で，失敗したらエラーを表示して終了するようになります．

## print() 関数

`print()` です．これはコンソールに出力する関数だった筈です．
実は，それ以外の機能もあります．
ファイルハンドルを指定すると，そのファイルに出力してくれます．
このときに，ファイルハンドルを指定した後には，カンマがないことに注意してください．

```{.perl .numberLines}
print("Hello, World\n");

print($fh "Hello, World\n");  # カンマが無いことに注意
```

## 練習問題

1. プログラムを起動してから，todolist.txt ファイルの内容を確認してみましょう．
   (テキストエディタなどで確認してください)
2. ファイルに色々書き込んでみましょう．
   (練習問題の 4.1 の結果を出力すると良いでしょう．)

---

# TODO を追加する

さっきの例では，1つのプログラムから固定の TODO しか作れませんでした．
こんどは，プログラムを変えないで，新しい TODO を追加する機能を作りましょう．

## 04_add_todo.pl


```{.perl .numberLines}
#!/usr/bin/env perl

use strict;
use warnings;

# 1行読み込む
print("Input todo : ");
my $content = <STDIN>;
chomp($content);
print($content, "\n");

# 既存のファイルに新しいTODO を追記する
open(my $fh, ">>", "todolist.txt") or die;
print($fh $content, "\n");
close($fh) or die;
```

## 解説

コメントを書いておきましたから，ある程度は推測できるかと思います．
コンソールから，TODO を読み込んで，`"todolist.txt"` というファイルに，追記します．

## 行入力演算子

`<>` (この場合だと `<STDIN>`) は，演算子です．
今までに出てきたものとちょっと使い方が違います．

今までの演算子の使い方の例．

```{.perl .numberLines}
1 + 2;      # => 3 : 数値, 数値 → 数値
"a" x 3;    # => aaa  文字列, 数値 → 文字列
```

今までに出てきた演算子は，全て演算子の両側に引数を取っていました．
`<>` は，`< + ファイルハンドル + >` のように真ん中に引数であるファイルハンドルを書きます．

ですので，`<STDIN>`の引数は，`STDIN` というファイルハンドルです．
`STDIN` は，コンソールからの入力が溜められているファイルハンドルです．
`open()` 関数のところで出てきたものと同じファイルハンドルですが，
変数ではなく `STDIN` という名前で参照できます．
又，自分で`open()` せずとも使うことができます．

```{.perl .numberLines}
my $line;

# コンソールから1行読み込む
$line = <STDIN>;

# ファイルから1行読み込む
open(my $fh, "<", "filename_in.txt") or die;
$line = <$fh>;
close($fh) or die;
```

* ファイルハンドル → 文字列
    * 行入力演算子 : `<>`
        * 例: `<STDIN>`, `<$fh>`

## スカラの自動変換

Perl は，スカラ値の自動変換が行われます．

```{.perl .numberLines}
# 文字列 → 数値 への自動変換 ("10" → 10)
1 + "10"; # => 11

# 数値 文字列の自動変換 (3 → "3")
3 x 4; # => 3333
```

Perl がうまくやってくれるので，あまり気にしなくともいいでしょう．
こういうことが起きているということだけ知っておいてください．

自動変換は，文字列 → 数値で良く起きます．
例えば，コンソールから受け取った値は，文字列です．
それを数値計算に使う場合などに起きています．

```{.perl .numberLines}
my $num = <STDIN>;

my $ans = $num * 2;   # <= ここで，* 演算子の引数は数値なので，
                      #    文字列→数値の変換が起こっている
print($num, " * 2 = ", $ans, "\n");
```

文字列 → 数値 変換は，先頭の数字を使うので，イメージしやすいでしょう．

```{.perl .numberLines}
"100" + 0;     # => 100
"1.2" + 0;     # => 1.2
"5ato" + 0;    # => 5
"zero10" + 0;  # => 0
```

## chomp() 関数

`chomp()` は，末尾の改行を取り除きます．
変数を指定すると，その変数にひもづいている値が変更されます．

入力された文字列は，よく最後の改行が残った状態であることが多いので，
そのときに使います．

```{.perl .numberLines}
my $line = <STDIN>;
chomp($line);

print($line, "\n");
```

## 練習問題

1. プログラムを実行してみてファイルの中身を見て TODO が追記されていることを確認しましょう
   (テキストエディタなどで確認すれば良いでしょう)
2. 半径を入力したら，直径を表示するプログラムを作ってください
3. 何個かの入力をして，計算をするプログラムを書いてみてください．例えば，
   2つの数を入力してもらって，足し算をするプログラムなどです
4. ファイル(ex7\_4\_in.txt)を読み込んで，ファイル(ex7\_4\_out.txt)を出力するプログラムを作ってみてください．
   (入力するファイルは，先頭の2行しか使われないこととします．3行目以降は無視してください)

入力(ex7\_4\_in.txt)
```{.numberLines}
3
4
```
出力(ex7\_4\_out.txt)
```{.numberLines}
7
12
3333
```

---

# 現在 の TODO を表示する

TODO を追加するところまでできるようになりました．
では，現在の TODO 全部を表示できるようなプログラムを作りましょう．

## 05_list_todo.pl

```{.perl .numberLines}
#!/usr/bin/env perl

use strict;
use warnings;

open(my $fh, "<", "todolist.txt") or die;
my $count = 1;
while (defined(my $line = <$fh>)) {
    print($count, ":", $line);
    $count = $count + 1;
}
close($fh) or die;
```

## 解説

TODO リストのファイルを読み込んで，各行に行数を付けてコンソールに出力しています．

## defind() とファイルの終端

`<>` 行入力演算子は，ファイルの終端まで入力が進むと，`undef` という値を返す．
これもスカラ値です．

`defined()` 関数は，引数が `undef` かどうか判定してくれて，真偽値を返してくれます．
真偽値については，次の `while` の条件部分のところで触れます．

## while 文

`while` というのは，とある条件が満たされている間に，何か別のことを行う．
というときに使います．

例えば，`while (A) { B }` のようになっていたら，最初に A が満たされているかチェックし，
満たされていれば，B を処理し，次に A をチェック，B を処理… で A が満たされなくなったときに，
この繰り返しが終了し，次の行に処理が移動します．

条件が満たされている状態を*真*，そうでない状態を*偽* と呼びます．
Perl では，*偽*とはスカラ値で言うと，`undef`，数値の `0`，文字列の `""` (空文字列) です．
又，文字列 `"0"` は，数値 `0` に自動変換されるので，これも*偽*です．
`""` 空文字列に自動変換される数値はありませんので，逆はありません．
*真* は，それ以外で表現できます．

* ブーリアン(スカラ版)
    * 偽 : `undef`, `0`, `""`, `"0"`
    * 真 : それ以外

例えば，

```{.perl .numberLines}
while (1) {
    print("hello", "\n");   # 実行する前に説明を読んでね
}
```

この場合は，条件部分が `1` となっていて，これは数値の `0` ではないので，
常に*真* です．つまり `print()` 文を処理し，条件に戻っても，常に真なので，
`print()` が無限に繰り返されることになります．

無限に繰り返すのはあまり良くないので，繰り返しの回数を決めて処理することがよくあります．

例えば，

```{.perl .numberLines}
my $count = 1; # 最初の値
while ($count < 10) { # 繰り返しは，count が 10 になったら終了する
    print($count, "\n");
    $count = $count + 1; # 繰り返しのたびに値を更新している
}
```

こうすると，最初は `$count` が `1` ですが，ブロックの中の `$count = $count + 1` が実行されるたびに `$count` の値が1つずつ増えていくので，`$count` が `10` になったら，繰り返しが終了します．
この処理はよくあるので覚えておくと良いでしょう．

## インデント

`while` の `{}` の中は，他の行と字下げが違って1段下がっています．
これは*インデント*と言って，ブロックを見分けやすくするために使います．
どこまでが1つの単位かわかりやすくなるので，空行と共に必ずやった方がよいと思います．

`{}` の中身の部分は，基本的には，インデントすると覚えておいてください．

## 補足 - 計算の順序(優先順位)

`$count = $count + 1` というのは，見たままだとわかりにくいかもしれません．

`=`(イコール) は，代入の記号という話をしました．
`+` は，演算子です．
これらは，計算の順序が違えば，`($count = $count) + 1` となってもおかしくありません．

先の説明だと `$count = ($count + 1)` となる．という旨の説明をしました．
(`+` が優先されて，その計算結果が代入に使われる)
これは，演算子の*優先順位* によって決定されます．
`=` は `+` のような計算よりも優先順位が低くなっているので，`+` が先に計算されます．

演算子の優先順位を完全に覚えている人はあまり多くないと思います．
気になったら，上記のように括弧で囲んでしまえば，優先順位を気にしないで，プログラムを書くことができます．
慣れてきたら，括弧を最低限の量しか付けないでも書けるようになります．

式が長くなりそうだったら，明示的に括弧を付けることを推奨します．

## ブーリアン演算子

ブーリアンを扱う演算子がいくつかあります．
例えば数値に対してだと，`<`, `>` などの記号は見たことがあるのではないでしょうか？
これらは，ご存知の通りに数値の大小でブーリアンとして適切なスカラ値を返します．

* 演算子
    * 数値，数値 → ブーリアン[^boolean_context]
        * `<`, `>`, `<=`, `>=`, `==`, `!=`
    * 文字列，文字列 → ブーリアン
        * `eq`, `ne`
    * ブーリアン，ブーリアン → ブーリアン
        * `and`, `or`, `&&`, `||`
    * ブーリアン → ブーリアン
        * `not`, `!`

[^boolean_context]: 正確には，ブーリアン値というスカラ値は存在しないのですが便宜上ブーリアン値があるように記述とさせて頂きます．

## 練習問題

1. ファイルの中身を読み込んで，全部コンソールに出力するプログラムを書いてみましょう
2. 1 から 10 までの数を表示するプログラムを書いてみてください．
   (ヒント．`$n = $n + 1` をブロックの中で使うと，数を順に進めることができます．又，`10` まで，というのは，`10` 以下[^less_than_equal]である間，と考えてもいいかもしれません．)
3. `1` から `10` までの数を足した結果を表示するプログラムを書いてみてください．
   (ヒント．足した結果を保持するスカラ変数，`$sum` を使うといいかもしれません．)
4. 数字(n) を入力して，`1` から n までを足した結果を出力するプログラムを書いてみてください．
5. `20` 未満[^less_than]の数で，`1`, `4`, `7`, ... のように，3ずつ離れた数を出力するプログラムを書いてみてください．
6. `"quit"` という文字列を入力しないと終わらないプログラムを書いてみてください．

[^less_than_equal]: X以下，X以上，というのは，Xを含んで下，Xを含んで上，を意味します．演算子だと `<=`, `>=` を使います．

[^less_than]: X未満，Xを超え，という単語は，Xより下，Xより上，と読み替えてもいいです．演算子だと `<`, `>` を使います．

---

# TODO を完了済みにする

TODO を完了させられなければ，TODO リストとしては未完成です．
TODO を指定して，その TODO を完了済み(Done) としてマークできるようにしましょう．

## 06_done_todo.pl

```{.perl .numberLines}
#!/usr/bin/env perl

use strict;
use warnings;

# 番号を入力
print("which number?: ");
my $num = <STDIN>;
chomp($num);

# 一旦TODO リストの中身を読み込む
open(my $rfh, "<", "todolist.txt") or die;
my @lines;
while (defined(my $line = <$rfh>)) {
    push(@lines, $line);
}
close($rfh) or die;

# 指定した番号のTODO を完了にして，TODO リストに書き込む
open(my $wfh, ">", "todolist.txt") or die;
my $count = 1;
foreach my $line (@lines) {
    if ($num == $count) {
        $line = "Done," . $line;
    }
    print($wfh $line);
    $count = $count + 1;
}
close($wfh) or die;
```

## 解説

結構長くなってきました．
1段落毎に理解していけば良いと思います．

TODO リストのうち，完了にしたいものの番号を入力して，
一旦，TODO リストを全部読み込んで，
番号が一致したTODO を完了にして，ファイルに書き込んでいます．

## リスト / リスト変数

単一のデータとしてスカラ値があるという話をしました．
複数のスカラ値をまとめて取り扱うために，リストという値があります．

```{.perl .numberLines}
(1, 2, 3);
```

リストは，`()` (括弧)で囲まれて，`,` (カンマ) で区切られたスカラ値で表
現します．それぞれのスカラ値をリスト値の*要素* と言います．

スカラにスカラ変数があったように，リストにもリスト変数があります．
リスト変数は，`@ + 変数名` の形式です．
スカラ変数と同じように，`my` で宣言して，`=` で代入できます．

```{.perl .numberLines}
my @numbers = (1, 2, 3, 4, 5);
```

リストには，複数のスカラ値が含まれています．個別のスカラ値を取り扱うために，
`[]` を使って，添字で位置を指定します．位置は 先頭が `0` 番です．

```{.perl .numberLines}
my @numbers = (1, 2, 3, 4, 5);
$number[0];    # => 1
$number[2];    # => 3
```

リスト変数全体を表すときには，先頭の記号が，`@` ですが，リストの中のスカラ値部分を扱う場合には，
先頭の記号が `$` になります．スカラとして扱うときは `$`，リストとして扱うときは `@` として覚えてしまいましょう．
`[]` 内の数値(添字)は，リストの先頭からの位置で場所を指定します．先頭の位置は，`0` です．
リストの一部を代入して変更することもできます．

```{.perl .numberLines}
my @numbers = (1, 2, 3, 4, 5);
$number[0] = 10; # => @numbers は (10, 2, 3, 4, 5)
```

* 変数
    * リスト変数
        * リストとして扱うとき: `@ + 変数名`
        * スカラとして扱うとき: `$ + 変数名 + [ + 位置 + ]`

## foreach 文

`foreach` は，`while` と同じようにブロックを繰り返し処理します．
`while` と違うのは，ある条件を満たしている間繰り返すというものではなく，
リストの値を繰り返しに使います．

```{.perl .numberLines}
my @ns = (1, 2, 3); # リスト変数の初期化

foreach my $n (@ns) { # リストの値を繰り返す
    print($n, "\n");
}
```

これは，リスト変数の要素を全部を1つずつ出力します．

## push() 関数

リストを操作する関数の一つです．
リスト変数の最後にに要素を追加します．

```{.perl .numberList}
my @numbers; # @numbers => ()

push(@numbers, 1); # @numbers => (1)
push(@numbers, 2); # @numbers => (1, 2)
push(@numbers, 3); # @numbers => (1, 2, 3)
```

## if 文

`while` と同じように，条件とブロックがあります．
`while` と違い繰り返したりしません．
条件式が*真*であればブロックを実行，そうでなければ，ブロックを実行しません．

```{.perl .numberLines}
my $input = <STDIN>;
if ($input) {
    print("Your input(", $input, ") is true", "\n");
}
```

## 練習問題

1. `alpha bravo charlie delta echo` のような文字列のリストを作り，それを順に出力するプログラムを書いてください．
2. 半径を入力して直径を出力するプログラムを作りましたが，半径が負の数だったら，直径として 0 を表示するようにしてください
3. 以下のプログラムがどうなるか予想して，実際に確認してみてください

```{.perl .numberLines}
if ("0") {
    print("I heard truth", "\n");
}
```

4. 例えば以下のようなファイルを自分で作成して，そこから数字取得して，全部を合計してコンソールに出力するプログラムを書いてください．入力ファイルは各行に1つずつ数字があるようにしてください．

ex9\_4\_in.txt

```{.perl .numberLines}
1
3
8
10
```
5. 前の問題のプログラムで，入力が奇数のものの合計を出力するように変更してみてください．
   (奇数の判定は，`$n % 2 != 0` とするとよいでしょう．ちなみに `%` は余りを出す演算子で，2 で割った余りが0でなければ奇数です)

---

# TODO の内容のうち未完了のものだけ表示する

終了した TODO は見る必要が無いと思います．
では，TODO のうち未完了のものだけ表示するプログラムを作りましょう．

## 07_list_notyet_todo.pl

```{.perl .numberLines}
#!/usr/bin/env perl

use strict;
use warnings;

# TODO リストを読み込んで，完了でないものだけ出力
open(my $fh, "<", "todolist.txt") or die;
my $count = 1;
while (defined(my $line = <$fh>) {
    chomp($line);
    my ($state, $content) = split(/,/, $line);
    if ($state ne "Done") {
        print($count, ":", $line, "\n");
    }
    $count = $count + 1;
}
close($fh) or die;
```

## 解説

やっていることは，ファイルの内容を読み込んで，
完了状態でない行だけ，行番号と共にコンソールに出力しています．

## split() 関数

`split()` は，区切り文字と文字列を引数に取り，文字列を分割します．

文字列を分割して，文字列のリストを返します．

## スカラコンテキスト / リストコンテキスト

コンテキストは，その位置に置かれたものは，何として扱われるか，ということです．
言葉だけではイメージできないと思いますので，例を上げます．

```{.perl .numberLines}
# スカラーコンテキスト
my $line = <>;

# リストコンテキスト
my ($line1, $line2, $line3) = <>;
```

`<>` 行入力演算子に何を求めているか，でコンテキストが違う．と表現します．
例えば，上の例で `my $line = <>` の方は，代入の相手がスカラ変数なので，
`<>` もスカラを返そうとします．これがスカラコンテキストです．
又，`my ($line1, $line2, $line3) = <>` の方は，代入の相手はスカラではありません．
`<>` に複数の値を求めています．リストコンテキストと呼ばれます．

見分け方としては，代入先が `()` (括弧) を使っているか，リスト変数か否かです．

```{.perl .numberLines}
my ($line) = <>;
```

これは，最初の例と同じように見えますが，`()` を使っているのでリストコンテキストになります．

では，コンテキストが違うということがわかったところで，
`<>` は，コンテキストによってどういう違いがあるかというと，
スカラコンテキストでは，1行だけ結果を返していたのが，
リストコンテキストでは，全部の行をリストで返します．

では，以下のような場合，入力が3行以上あったとすると，どうなるでしょうか？

```{.perl .numberLines}
my ($line1, $line2) = <>;
```

答は，3行目以降は捨てられます．逆に入力が足りなかった場合には，`undef` で埋められます．例えば1行しか入力が無かったら，`$line2` は `undef` になります．

上記の例は，代入でしたが，`while` などの条件式や演算子の引数もスカラコンテキストです．

* コンテキスト
    * スカラコンテキスト
        * スカラ変数への代入，条件式，演算子の引数部分
    * リストコンテキスト
        * それ以外

## 練習問題

1. 例えば，"2014,10,20" のような文字列を入力したら，"2014年10月20日です" という文字列を出力するプログラムを書いてみてください．
2. 1行に1つずつの数のリストを入力の終りまで読み込んで，以下に示す人名の
  リストから数に対応する人名を表示するプログラムを書いてください．
  例えば，入力された番号が 1, 2, 4, 2 だとすると，fread, betty, dino,
  betty となります．
  
    fred betty barney dino wilma pebbles bamm-bamm

---

# まとめ

TODO リストを操作するプログラムを作ってみました．
そのプログラムの解説をすることで，Perl プログラムの基礎を学びました．

プログラミング言語の基本的な性質について学びました．

* データ，データ構造
* 演算子
* 分岐(if)
* 繰り返し(while)
* ファイルの書き込み，読み込み

TODO リストの機能の最低限のものは作りましたが，まだ機能としては不十分です．
また引き続きお付き合いして頂くか，自分で改良してみてください．

---

# おさらい

この会で Perl プログラミングについて学んだことをおさらいします．

## 準備

* 作業ディレクトリを作って，そこで作業した
    * ファイル名を指定すると，作業ディレクトリのファイルを指定したこと
      になる
* テキストエディタでPerl のプログラムファイルを作ることができる
* Perl プログラムファイルをコンソールから実行できる

## 基礎文法

* ファイル名は，`.pl` で終わるようにする
* `#` (シャープ) から行末までは，コメントとして扱われてプログラムとし
  ては実行されない
* 行の区切りに `;` (セミコロン) を付ける
* 下記の基本の行を必ず書く

```{.perl .numberLines}
#!/usr/bin/env perl

use strict;
use warnings;
```
* 空行(からぎょう) は，意味の分割のために使う

## スカラ値

* 1つ分のデータのことをスカラと呼ぶ
* スカラにはいくつかの種類がある
    * 数値
    * 文字列
    * ファイルハンドル
    * `undef`

```{.perl .numberLines}
# 数値の例
1
10
2.5
-100

# 文字列の例
"文字列"
"\n"
"Hello, World"

# ファイルハンドルの例
open(my $fh, "<", "filename") or die; # この内の $fh に入っている
STDIN

# undef の例
my $var;  # 変数を宣言だけして，代入する前には undef になっている
$var = undef;
```

又，場所によってスカラ値はブーリアン，真偽値としても扱われる．

* ブーリアン，真偽値
    * 偽: `0`, `""`, `undef`, `"0"`
    * 真: それ以外

```{.perl .numberLines}
# 偽
if (0) {
    print("I said truth", "\n");
}
if ("") {
    print("I said truth", "\n");
}
if (undef) {
    print("I said truth", "\n");
}

# 真
if (1) {
    print("I heard truth", "\n");
}
if ("a") {
    print("I heard truth", "\n");
}
```

## リスト値

複数のスカラをまとめて扱う．

## 変数

### スカラ変数

* スカラ変数はスカラに名前を付ける
* 最初に使うときには `my` をつける
* スカラ変数にスカラをひもづけるときには，`=` (イコール) を使う．
    * 代入と言う

### リスト変数

* リスト値に名前を付ける
* 最初に使うときには，`my` をつける
* 代入には，`=` を使う
* それぞれのスカラ値を取り扱うときには，`[]` を使う
    * 例: `$ary[0]`, `$ary[0] = 10`

## 演算子

引数を取って，新しい値を返す．

* 数値，数値 → 数値
    * 四則演算: `+`, `-`, `*`, `/`
* 文字列，文字列 → 数値
    * 文字列連結: `.`
* 文字列，数値 → 数値
    * 文字列繰り返し: `x`
* ファイルハンドル → 文字列
    * 行入力演算子: `<>`
* 数値，数値 → ブーリアン
    * `<`, `>`, `<=`, `>=`, `==`, `!=`
* 文字列，文字列 → ブーリアン
    * `eq`, `ne`
* ブーリアン，ブーリアン → ブーリアン
    * `and`, `or`, `&&`, `||`
* ブーリアン → ブーリアン
    * `not`, `!`
    
## 関数

関数は，`関数名 + "(" + 引数1 + ", " + 引数2 ... ")"` の形式で呼び出す．

`print()`

:   引数をコンソールに出力する．
    最初の引数をファイルハンドルにすると，そのファイルハンドルに出力する

`open()`

:   指定したファイルのファイルハンドルを作る．
    `"<"` 読み込み，`">"` 書き込み，`">>"` 追記のモードがある．

`close()`

:   ファイルハンドルの後片付けをする．

`chomp()`

:   引数の値の末尾の改行文字を削除する．

`push()`

:   リスト変数の末尾に値を追加する．
    
`split()`

:   文字列を区切りで区切って，リスト値にして返す．

## if 文

`if` は，ブロックを実行するかしないかを，条件式で決めます．

```{.perl .numberLines}
my $a = 10;
if ($a > 5) {
    print("over", "\n");
}
```

## while 文

`while` では繰り返し処理を行うことができます．
条件式の中は，ブーリアンとして解釈され，条件式が真の間，ブロックの中を実行し続けます．

```{.perl .numberLines}
my $count = 0;
while ($count < 5) {
    print($count, "\n");
    $count = $count + 1;
}
```

## コンテキスト

コンテキストによって，動作を変える演算子，関数がある．

* コンテキスト
    * スカラコンテキスト
        * スカラへの代入，条件式部分，演算子の引数
    * リストコンテキスト
        * それ以外

例えば，以下があります．

* `<>` 行入力演算子
    * スカラ: 1行分だけ返す
    * リスト: 全部の行をリストにして返す

---

# 練習問題の答

## 3. 練習問題

### 2

`print()` を次の行に書くことができます．

ex3_2.pl

```{.perl .numberLines}
#!/usr/bin/env perl

use strict;
use warnings;

print("tetsu", "\n");
print("17", "\n");
```

このように1行に書いても同じように表示することができます．

```{.perl .numberLines}
print("tetsu\n17\n");
```

### 3

`perldoc` というコマンドは，Perl 言語のドキュメント(解説，説明) をコンソールに表示させることができるコマンドです．
(残念ながら英語です)

`atan2()` という関数の説明を表示しています．

### 4

説明していないものがいくつか出ていますが，説明をします．

``` `` ```(バッククォート) この演算子は，囲まれた部分をコマンドとして実行して，その出力結果を返します．
この場合は，`perldoc -u -f atan2` を実行します．実行結果は，見た通りです．

``` `` ``` の結果を，`@lines` 変数に保持しています．

`foreach` 文は，`while` のように繰り返しをします．
真偽値による条件ではなく，繰り返す回数は，指定されたリスト値の回数です．
`foreach` で，変数を指定しなければ，`$_` がリスト値の1つずつに入った状態で，
ブロックの中の繰り返しの処理を行います．

`s///` は，文字列の置き換えです．説明していませんが，*正規表現* を使って，
指定された文字列の中の一部を置き換えます．
この場合は，`X<aaa>` な文字列を `AAA` のように置き換えています．

`print` は，`print()` 関数のことで，何も指定しないとデフォルトで，`$_` 変数の内容を出力することになっています．

```{.perl .numberLines}
#!/usr/bin/env perl

# いつもの
use strict;
use warnings;

# atan2() という関数の説明を @lines というリスト変数に保持している
my @lines = `perldoc -u -f atan2`;

# @lines 変数の中身の各行を $_ というデフォルト変数に保持し，以下を繰り返す
foreach (@lines) {
    # $_ 変数の中の，何か1文字 + "<" + (">" 以外の文字1つ以上の連続) + ">" の部分を，さっきの ">" 以外の文字1つ以上の連続部分を大文字に，置き換える
    s/\w<([^>]+)>/\U$1/g;
    # $_ 変数の中身をコンソールに出力する
    print;
}
```

## 4. 練習問題

### 1.

出てきた演算子は，`+`, `-`, `*`, `/`, `.`, `x` です．
それぞれを使ってみて，演算子に慣れましょう．

```{.perl .numberLines}
#!/usr/bin/env perl

use strict;
use warnings;

print(1 + 3, "\n"); # => 4
print(3 - 1, "\n"); # => 2
print(2 * 5, "\n"); # => 10
print(5 / 2, "\n"); # => 2.5
print("aaa" . "bbb", "\n"); # => "aaabbb"
print("Abc" x 3, "\n"); # => "AbcAbcAbc"

print(1 + 2 * 3, "\n"); # => 7
```

### 2.

変数を使うときに最初に，`my` を入れるのを忘れないでください．

```{.perl .numberLines}
#!/usr/bin/env perl

use strict;
use warnings;

my $r = 12.5;
my $pi = 3.14;
print(2 * $pi * $r, "\n"); # => 78.5
```

## 5. 練習問題

### 1.

TODO の属性として良くあるのは，期限やカテゴリです．
それ以外にもTODOリストとして良い機能があれば教えてください．

## 6. 練習問題

### 1.

`print()` で書き込んだ内容がファイルの中にあることを確認してください．

### 2.

どんな内容でも良いですが，以下のようになると思います．
`open()` の後に `print()` があって，`close()` の順序になっていれば良いでしょう．

あと，書き込んだファイルの中身が想像通りになっているかどうかを確認してください．

```{.perl .numberLines}
#!/usr/bin/env perl

use strict;
use warnings;

open(my $fh, ">", "sample.txt") or die;
print($fh "This is test file.", "\n");
print($fh "書き込まれているでしょうか？", "\n");
close($fh) or die;
```

## 7. 練習問題

### 1.

実行結果を確認してみてください．
改行が入ってしまっていませんか？
ちゃんと入力した TODO が意図通りに追加されていましたか？

### 2.

半径を固定値ではなく，入力できるようにしたものです．

```{.perl .numberLines}
#!/usr/bin/env perl

use strict;
use warnings;

# 入力
my $r = <STDIN>;
chomp($r);

# 出力
my $pi = 3.14;
print("半径: ", $r, " の円周は ", 2 * $pi * $r, "\n");
```

### 3.

これは，入力した値を使って演算を行う例です．

以下の例だと，演算子の期待している入力になっていないと警告が出るかもしれません．
例えば，`+` は，数値を期待しているので，"a" などを入力すると，
`Argument "a" isn't numeric in ...` のような警告が出てしまうでしょう．
これらを回避する方法もありますが，一旦は無視します．

```{.perl .numberLines}
#!/usr/bin/env perl

use strict;
use warnings;

my $op1 = <STDIN>; # 入力を受け取る
chomp($op1); # 入力された改行文字を削除する

my $op2 = <STDIN>;
chomp($op2);

print($op1 + $op2, "\n");
print($op1 - $op2, "\n");
print($op1 * $op2, "\n");
print($op1 / $op2, "\n");
print($op1 . $op2, "\n");
print($op1 x $op2, "\n");
```

### 4.

```{.perl .numberLines}
#!/usr/bin/env perl

use strict;
use warnings;

# 入力
open(my $rfh, "<", "ex7_4_in.txt") or die;
my $op1 = <$rfh>;
chomp($op1);
my $op2 = <$rfh>;
chomp($op2);
close($rfh) or die;

# 出力
open(my $wfh, ">", "ex7_4_out.txt") or die;
print($wfh $op1 + $op2, "\n");
print($wfh $op1 * $op2, "\n");
print($wfh $op1 x $op2, "\n");
close($wfh) or die;
```


## 8. 練習問題

### 1.

まっすぐ書くとこのようになります．

```{.perl .numberLines}
#!/usr/bin/env perl

use strict;
use warnings;

open(my $fh, "<", "ex8_1_in.txt") or die;
while (defined(my $line = <$fh>)) {
    print($line);
}
close($fh) or die;
```

ファイル名を指定できるようにすると，以下のようになります．

```{.perl .numberLines}
#!/usr/bin/env perl

use strict;
use warnings;

my $filename = <STDIN>;
chomp($filename);

open(my $fh, "<", $filename) or die;
while (defined(my $line = <$fh>)) {
    print($line);
}
close($fh) or die;
```

### 2.

```{.perl .numberLines}
#!/usr/bin/env perl

use strict;
use warnings;

my $i = 1;
while ($i <= 10) {
    print($i, "\n");
    $i = $i + 1;
}
```

### 3.

```{.perl .numberLines}
#!/usr/bin/env perl

use strict;
use warnings;

my $i = 1;
my $sum = 0;
while ($i <= 10) {
    $sum = $sum + $i;
    $i = $i + 1;
}
print($sum, "\n");
```

### 4.

```{.perl .numberLines}
#!/usr/bin/env perl

use strict;
use warnings;

my $n = <STDIN>;
chomp($n);

my $i = 1;
my $sum = 0;
while ($i <= $n) {
    $sum = $sum + $i;
    $i = $i + 1;
}
print($sum, "\n");
```

### 5.

```{.perl .numberLines}
#!/usr/bin/env perl

use strict;
use warnings;

my $n = 1;
while ($n < 20) {
    print($n, "\n");
    $n = $n + 3; # 3ずつ離れている
}
```

### 6.

素直に書くとこのようになるでしょう．

```{.perl .numberLines}
#!/usr/bin/env perl

use strict;
use warnings;

my $input = <STDIN>;
chomp($input);
while ($input ne "quit") {
    $input = <STDIN>;
}
print("end...", "\n");
```

<STDIN> というのを二回書きたくなかったら．
スカラ変数が初期化時には，undef であることを利用して，
以下のように書くこともできます．

```{.perl .numberLines}
#!/usr/bin/env perl

use strict;
use warnings;

my $input;
while (!defined($input) or $input ne "quit") {
    $input = <STDIN>;
}
print("end...", "\n");
```

## 9. 練習問題

### 1.

```{.perl .numberLines}
#!/usr/bin/env perl

use strict;
use warnings;

my @chars = ("alpha", "bravo", "charlie", "delta", "echo");
my $i = 0;
while ($i < 5) {
    print($chars[$i], "\n");
    $i = $i + 1;
}
```

### 2.

```{.perl .numberLines}
#!/usr/bin/env perl

use strict;
use warnings;

my $r = <STDIN>;
chomp($r);
if ($r < 0) {
    $r = 0;
}

my $pi = 3.14;
print(2 * $pi * $r, "\n");
```

### 3.

`"0"` は，偽なので，`print()` は実行されません．

### 4.

```{.perl .numberLines}
#!/usr/bin/env perl

use strict;
use warnings;

open(my $fh, "<", "ex9_4_in.txt") or die;
my $sum = 0;
while (defined(my $n = <$fh>)) {
    chomp($n);
    $sum = $sum + $n;
}
close($fh) or die;

print($sum, "\n");
```

### 5.

```{.perl .numberLines}
#!/usr/bin/env perl

use strict;
use warnings;

open(my $fh, "<", "ex9_4_in.txt") or die;
my $sum = 0;
while (defined(my $n = <$fh>)) {
    chomp($n);
    if ($n % 2 != 0) {
        $sum = $sum + $n;
    }
}
close($fh) or die;

print($sum, "\n");
```

## 10. 練習問題

### 1.

```{.perl .numberLines}
#!/usr/bin/env perl

use strict;
use warnings;

# 入力
my $ymd = <STDIN>;
chomp($ymd);
my ($y, $m, $d) = split(/,/, $in);

# 出力
print($y, "年", $m, "月", $d, "日です", "\n");
```

### 2.

数値を読み込んで，配列の添字に使うことがわかればできます．
リストの添字は，`0`から始まるので，入力する数字と1つずれていることに注意が必要です．

```{.perl .numberLines}
#!/usr/bin/env perl

use strict;
use warnings;

my @names = ("fred", "betty", "dino", "wilma", "pebbles", "bamm-bamm");

my @indices;
while (defined(my $n = <STDIN>)) {
    chomp($n);
    push(@indices, $n - 1);
}

foreach my $index (@indices) {
    print $names[$index]; # 添字とズレているので注意
}
```

---

# 付録

## perli / perl -de0

簡単に調査したいときに毎回ファイルを作って実行するのは面倒ですよね．
例えば，`perli` というコマンドがあります．

`perli` のダウンロード

```{.bash .numberLines}
$ curl -LO https://raw.githubusercontent.com/mklement0/perli/master/bin/perli
$ chmod +x perli
$ ./perli    # 又は，perl perli
```

`perli` は，Perl プログラムなので，ダウンロードしたらそのまま使うことができます．
`perli` を実行すると，簡単に値を調べることができます．

```{.perl .numberLines}
> 1
1
> defined(undef)
''
> defined(10)
1
> not 1
''
> (1, 2, 3)
1
2
3
```

色々試してみてもいいかもしれません．

同じ用途で，`perl -de0` というコマンドも使えますが，若干使い方が難しいです．
こちらは，`perl` があれば最初から使えるでしょう．

```{.perl .numberLines}
$ perl -de0
DB<1> x 1
0  1
DB<2> x defined(undef)
0  ''
DB<3> x (1,2,3)
0  1
1  2
2  3
```

`x` を先頭に付けてコマンドを実行します．結果はリスト値が添字と一緒に順に縦に並びます．

---

# さいごに

練習問題や文章の一部は，『初めての Perl』 のものをお借りしています．
素晴しいテキストありがとうございます．

これを読んだ人がプログラミングを挫折しないで学べるようになることを望んで書きました．

なるべく覚えることを減らして，1つの章でポイントを絞って書くようにしました．
その代わり網羅性は考えないことにしました．一般のプログラミング言語の入門書に通常あるようなことでも書いていないことがあります．
10個のことを覚えるより，1つのことを10回やった方がうまくなると思っているからです．

勉強した方の生活がどこか楽になってくれると嬉しく思います．

---
